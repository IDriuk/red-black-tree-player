{"version":3,"sources":["config/index.js","animations/AnimatedTree.js","algorithms/RedBlackTree.js","algorithms/BinaryTree.js","helpers/initSvg.js","helpers/defineArrowMarkers.js","helpers/canvasTest.js","components/Tree.js","App.js","serviceWorker.js","index.js"],"names":["identity","i","AnimatedRedBlackTree","canvas","value","identifier","color","coordinates","center","x","y","linkToParent","x1","y1","x2","y2","linkToLeftChild","linkToRightChild","svgEls","circle","valueTxt","topArrow","leftArrow","rightArrow","this","parent","updateCoordinates","start","animateToCoordinates","replacement","children","undefined","isRightChild","right","left","forEach","child","kid","paintBlack","dir","insert","paint","RedBlackTree","_insert1","_insert2","isBlack","_insert3","uncle","isRed","grandparent","paintRed","_insert4","isLeftChild","rotateLeft","rotateRight","_insert5","identifiedValue","thisValue","rmPaint","remove","hasTwoChildren","_remove0","standardRemove","isLeaf","isRoot","hasOneChild","rmDir","replica","_minimumChild","childIsRed","_remove1","_remove2","sib","sibling","_remove3","sibIsBlack","sibLeftBlack","sibRightBlack","_remove4","_remove5","_remove6","count","countBlackToRoot","_rotate","_swapWithParent","opposite","oppDir","pivot","BinaryTree","newTree","find","current","_maximumChild","every","initSvg","svg","d3","append","attr","CANVAS_WIDTH","CANVAS_HEIGHT","defs","defineArrowMarkers","canvasTest","t","duration","transition","runVisualization","a","animatedTree","AnimatedTree","console","log","Tree","useEffect","App","className","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.bad6886e.chunk.js","sourcesContent":["// algorithms constants\nexport const identity = i => i;\nexport const LEFT = 0;\nexport const RIGHT = 1;\nexport const oppDir = dir => (dir === RIGHT ? LEFT : RIGHT);\nexport const BLACK = \"b\";\nexport const RED = \"r\";\n\n// drawing constants\nexport const CANVAS_WIDTH = 800;\nexport const CANVAS_HEIGHT = 400;\nexport const CIRCLE_RADIUS = 20;\n","import {\n  identity,\n  LEFT,\n  RIGHT,\n  oppDir,\n  BLACK,\n  RED,\n  CIRCLE_RADIUS\n} from \"../config\";\nimport RedBlackTree from \"../algorithms/RedBlackTree\";\n\nexport default class AnimatedRedBlackTree extends RedBlackTree {\n  constructor(canvas, value, identifier, color) {\n    super(value, identifier, color);\n    this.canvas = canvas;\n\n    this.coordinates = {\n      center: { x: false, y: false },\n      linkToParent: { x1: false, y1: false, x2: false, y2: false },\n      linkToLeftChild: { x1: false, y1: false, x2: false, y2: false },\n      linkToRightChild: { x1: false, y1: false, x2: false, y2: false }\n    };\n\n    this.svgEls = {\n      circle: false,\n      valueTxt: false,\n      topArrow: false,\n      leftArrow: false,\n      rightArrow: false\n    };\n  }\n\n  updateCoordinates(center) {\n    if (center) {\n      // calculate linkToParent, link to left, link to right, left child center, right child center\n      // call updateCoordinates for childs with centers\n    } else if (this.parent) {\n      this.parent.updateCoordinates();\n    } else {\n      // it is root node\n      // remove link to parent, calculate left center, right center, left link, calculate right link\n      // call updateCoordinates for childs with centers\n    }\n  }\n\n  async animateToCoordinates(start) {\n    if (start) {\n      // run transitions of all svgEls to new coordinates\n      // await Promise.all[collection of promises from childs]\n    } else if (this.parent) {\n      this.parent.animateToCoordinates();\n    } else {\n      // it is root node\n      // call elements animation to coordinates with start true for all childs\n      // await Promise.all[collection of promises from childs]\n    }\n  }\n\n  async _swapWithParent() {\n    let replacement = new AnimatedRedBlackTree(\n      this.canvas,\n      this.value,\n      this.identifier,\n      this.color\n    );\n    replacement.parent = this.parent;\n    replacement.children = this.children;\n    if (this.parent !== undefined) {\n      if (this.isRightChild) {\n        this.parent.right = replacement;\n      } else {\n        this.parent.left = replacement;\n      }\n    }\n\n    this.value = replacement.parent.value;\n    this.children = replacement.parent.children;\n    this.parent = replacement.parent.parent;\n    this.color = replacement.parent.color;\n\n    this.children.forEach(child => {\n      if (child) child.parent = this;\n    });\n    this.children.forEach(child => {\n      if (child)\n        child.children.forEach(kid => {\n          if (kid) kid.parent = child;\n        });\n    });\n  }\n\n  async insert(value) {\n    if (this.value === undefined) {\n      this.value = value;\n      this.paintBlack();\n      return;\n    }\n    let dir;\n    if (this.identifier(value) > this.identifier(this.value)) {\n      dir = RIGHT;\n    } else {\n      dir = LEFT;\n    }\n    if (this.children[dir] !== undefined) {\n      return this.children[dir].insert(value);\n    } else {\n      let child = new AnimatedRedBlackTree(\n        this.canvas,\n        value,\n        this.identifier,\n        RED\n      );\n      child.parent = this;\n      this.children[dir] = child;\n      child.paint();\n      return child;\n    }\n  }\n}\n","import { identity, LEFT, RIGHT, BLACK, RED } from \"../config\";\nimport BinaryTree from \"./BinaryTree\";\n\nexport default class RedBlackTree extends BinaryTree {\n  constructor(value, identifier = identity, color = BLACK) {\n    super(value, identifier);\n    this.color = color;\n  }\n\n  _swapWithParent() {\n    let replacement = new RedBlackTree(this.value, this.identifier, this.color);\n    replacement.parent = this.parent;\n    replacement.children = this.children;\n    if (this.parent !== undefined) {\n      if (this.isRightChild) {\n        this.parent.right = replacement;\n      } else {\n        this.parent.left = replacement;\n      }\n    }\n\n    this.value = replacement.parent.value;\n    this.children = replacement.parent.children;\n    this.parent = replacement.parent.parent;\n    this.color = replacement.parent.color;\n\n    this.children.forEach(child => {\n      if (child) child.parent = this;\n    });\n    this.children.forEach(child => {\n      if (child)\n        child.children.forEach(kid => {\n          if (kid) kid.parent = child;\n        });\n    });\n  }\n\n  paintBlack() {\n    this.color = BLACK;\n  }\n\n  paintRed() {\n    this.color = RED;\n  }\n\n  get isBlack() {\n    return this.color === BLACK;\n  }\n\n  get isRed() {\n    return this.color === RED;\n  }\n\n  insert(value) {\n    if (this.value === undefined) {\n      this.value = value;\n      this.paintBlack();\n      return;\n    }\n    let dir;\n    if (this.identifier(value) > this.identifier(this.value)) {\n      dir = RIGHT;\n    } else {\n      dir = LEFT;\n    }\n    if (this.children[dir] !== undefined) {\n      return this.children[dir].insert(value);\n    } else {\n      let child = new RedBlackTree(value, this.identifier, RED);\n      child.parent = this;\n      this.children[dir] = child;\n      child.paint();\n      return child;\n    }\n  }\n\n  paint() {\n    return this._insert1();\n  }\n\n  _insert1() {\n    if (this.parent === undefined) {\n      this.paintBlack();\n      return;\n    } else {\n      this._insert2();\n    }\n  }\n\n  _insert2() {\n    if (this.parent.isBlack) {\n      return;\n    } else {\n      this._insert3();\n    }\n  }\n\n  _insert3() {\n    let uncle = this.uncle;\n    if (uncle ? uncle.isRed : false) {\n      this.parent.paintBlack();\n      uncle.paintBlack();\n      this.grandparent.paintRed();\n      this.grandparent.paint();\n      return;\n    } else {\n      this._insert4();\n    }\n  }\n\n  _insert4() {\n    if (this.isRightChild && this.parent.isLeftChild) {\n      this.parent.rotateLeft();\n      return;\n    } else if (this.isLeftChild && this.parent.isRightChild) {\n      this.parent.rotateRight();\n      return;\n    }\n    this._insert5();\n  }\n\n  _insert5() {\n    this.parent.paintBlack();\n    this.grandparent.paintRed();\n    if (this.isLeftChild) {\n      this.grandparent.rotateRight();\n    } else {\n      this.grandparent.rotateLeft();\n    }\n    return;\n  }\n\n  remove(value) {\n    let identifiedValue = this.identifier(value);\n    let thisValue = this.identifier(this.value);\n    if (thisValue === identifiedValue) {\n      this.rmPaint(value);\n      return;\n    } else {\n      let dir;\n      if (thisValue < identifiedValue) {\n        dir = RIGHT;\n      } else {\n        dir = LEFT;\n      }\n      if (this.children[dir] === undefined) {\n        return undefined;\n      } else {\n        return this.children[dir].remove(value);\n      }\n    }\n  }\n\n  rmPaint(value) {\n    if (!this.hasTwoChildren) {\n      this._remove0();\n    }\n    this.standardRemove(value);\n  }\n\n  standardRemove(value) {\n    if (this.isLeaf) {\n      if (this.isRoot) {\n        this.value = undefined;\n        this.paintBlack();\n      } else if (this.isRightChild) {\n        this.parent.right = undefined;\n      } else if (this.isLeftChild) {\n        this.parent.left = undefined;\n      }\n    } else if (this.hasOneChild) {\n      let rmDir = this.right ? LEFT : RIGHT;\n      this.right ? this.rotateLeft() : this.rotateRight();\n      this.children[rmDir] = undefined;\n    } else if (this.hasTwoChildren) {\n      let replica = this.right._minimumChild();\n      this.value = replica.value;\n      this.right.remove(replica.value);\n    }\n  }\n\n  _remove0() {\n    let childIsRed = this.hasOneChild\n      ? this.right\n        ? this.right.isRed\n        : this.left.isRed\n      : false;\n    if (this.isBlack) {\n      if (childIsRed) {\n        this.right ? this.right.paintBlack() : this.left.paintBlack();\n      } else {\n        if (this.parent ? this.parent.isBlack : false) {\n          this._remove1();\n        }\n      }\n    }\n  }\n\n  _remove1() {\n    if (this.parent !== undefined) this._remove2();\n  }\n\n  _remove2() {\n    let sib = this.sibling;\n    if (sib && sib.isRed) {\n      this.parent.paintRed();\n      sib.paintBlack();\n      if (this.isLeftChild) {\n        this.parent.rotateLeft();\n      } else if (this.isRightChild) {\n        this.parent.rotateRight();\n      }\n    }\n    this._remove3();\n  }\n\n  _remove3() {\n    let sib = this.sibling;\n    let sibIsBlack = sib ? sib.isBlack : true;\n    let sibLeftBlack = sib ? (sib.left ? sib.left.isBlack : true) : true;\n    let sibRightBlack = sib ? (sib.right ? sib.right.isBlack : true) : true;\n    if (\n      this.parent.isBlack &&\n      sib &&\n      sibIsBlack &&\n      sibLeftBlack &&\n      sibRightBlack\n    ) {\n      sib.paintRed();\n      this.parent._remove1();\n    } else {\n      this._remove4();\n    }\n  }\n\n  _remove4() {\n    let sib = this.sibling;\n    let sibIsBlack = sib ? sib.isBlack : true;\n    let sibLeftBlack = sib ? (sib.left ? sib.left.isBlack : true) : true;\n    let sibRightBlack = sib ? (sib.right ? sib.right.isBlack : true) : true;\n    if (\n      this.parent.isRed &&\n      sib &&\n      sibIsBlack &&\n      sibLeftBlack &&\n      sibRightBlack\n    ) {\n      sib.paintRed();\n      this.parent.paintBlack();\n    } else {\n      this._remove5();\n    }\n  }\n\n  _remove5() {\n    let sib = this.sibling;\n    if (\n      this.isLeftChild &&\n      (sib.right ? sib.right.isBlack : true) &&\n      (sib.left ? sib.left.isRed : false)\n    ) {\n      sib.paintRed();\n      sib.left.paintBlack();\n      sib.rotateRight();\n    } else if (\n      this.isRightChild && (sib.left ? sib.left.isBlack : true) && sib.right\n        ? sib.right.isRed\n        : false\n    ) {\n      sib.paintRed();\n      sib.right.paintBlack();\n      sib.rotateLeft();\n    }\n    this._remove6();\n  }\n\n  _remove6() {\n    let sib = this.sibling;\n    if (sib) this.parent.isBlack ? sib.paintBlack() : sib.paintRed();\n    this.parent.paintBlack();\n    if (this.isLeftChild) {\n      sib.right.paintBlack();\n      this.parent.rotateLeft();\n    } else {\n      sib.left.paintBlack();\n      this.parent.rotateRight();\n    }\n  }\n\n  countBlackToRoot(count = 0) {\n    if (this.parent === undefined) {\n      return count;\n    } else {\n      return this.isBlack\n        ? this.parent.countBlackToRoot(count + 1)\n        : this.parent.countBlackToRoot(count);\n    }\n  }\n}\n","import { identity, LEFT, RIGHT, oppDir } from \"../config\";\n\nexport default class BinaryTree {\n  constructor(value, identifier = identity) {\n    this.value = value;\n    this.children = [];\n    this.identifier = identifier;\n    this.parent = undefined;\n  }\n\n  get left() {\n    return this.children[LEFT];\n  }\n\n  get right() {\n    return this.children[RIGHT];\n  }\n\n  set left(value) {\n    this.children[LEFT] = value;\n  }\n\n  set right(value) {\n    this.children[RIGHT] = value;\n  }\n\n  get isRoot() {\n    return this.parent === undefined;\n  }\n\n  get isLeftChild() {\n    return this.parent ? this.parent.left === this : false;\n  }\n\n  get isRightChild() {\n    return this.parent ? this.parent.right === this : false;\n  }\n\n  get isLeaf() {\n    return this.children.every(child => child === undefined);\n  }\n\n  get grandparent() {\n    return this.parent ? this.parent.parent : undefined;\n  }\n\n  get uncle() {\n    return this.grandparent\n      ? this.parent.isRightChild\n        ? this.grandparent.left\n        : this.grandparent.right\n      : undefined;\n  }\n\n  get sibling() {\n    return this.parent\n      ? this.isRightChild\n        ? this.parent.left\n        : this.parent.right\n      : undefined;\n  }\n\n  get hasOneChild() {\n    return (\n      (this.right !== undefined && this.left === undefined) ||\n      (this.right === undefined && this.left !== undefined)\n    );\n  }\n\n  get hasTwoChildren() {\n    return this.right !== undefined && this.left !== undefined;\n  }\n\n  rotateLeft() {\n    this._rotate(LEFT);\n    this._swapWithParent();\n  }\n\n  rotateRight() {\n    this._rotate(RIGHT);\n    this._swapWithParent();\n  }\n\n  _rotate(dir) {\n    let opposite = oppDir(dir);\n    let pivot = this.children[opposite];\n    this.children[opposite] = pivot.children[dir];\n    pivot.children[dir] = this;\n    pivot.parent = this.parent;\n    pivot.children.forEach(child => {\n      if (child) child.parent = pivot;\n    });\n    this.children.forEach(child => {\n      if (child) child.parent = this;\n    });\n  }\n\n  _swapWithParent() {\n    let replacement = new BinaryTree(this.value, this.identifier);\n    replacement.parent = this.parent;\n    replacement.children = this.children;\n    if (this.parent !== undefined) {\n      if (this.isRightChild) {\n        this.parent.right = replacement;\n      } else {\n        this.parent.left = replacement;\n      }\n    }\n\n    this.value = replacement.parent.value;\n    this.children = replacement.parent.children;\n    this.parent = replacement.parent.parent;\n\n    this.children.forEach(child => {\n      if (child) child.parent = this;\n    });\n    this.children.forEach(child => {\n      if (child)\n        // point children to replacement\n        child.children.forEach(kid => {\n          if (kid) kid.parent = child;\n        });\n    });\n  }\n\n  insert(value) {\n    if (this.value === undefined) {\n      this.value = value;\n      return this;\n    } else {\n      let dir;\n      if (this.identifier(value) > this.identifier(this.value)) {\n        dir = RIGHT;\n      } else {\n        dir = LEFT;\n      }\n      if (this.children[dir] === undefined) {\n        let newTree = new BinaryTree(value, this.identifier);\n        newTree.parent = this;\n        this.children[dir] = newTree;\n        return newTree;\n      } else {\n        return this.children[dir].insert(value);\n      }\n    }\n  }\n\n  // return this.value which is is equal to value through identifier. why?\n  find(value) {\n    let identifiedValue = this.identifier(value);\n    let thisValue = this.identifier(this.value);\n    if (thisValue === identifiedValue) {\n      return this.value;\n    } else {\n      let dir;\n      if (thisValue < identifiedValue) {\n        dir = RIGHT;\n      } else {\n        dir = LEFT;\n      }\n      if (this.children[dir] === undefined) {\n        return undefined;\n      } else {\n        return this.children[dir].find(value);\n      }\n    }\n  }\n\n  contains(value) {\n    return this.find(value) !== undefined;\n  }\n\n  _minimumChild() {\n    let current = this;\n    while (current.left !== undefined) {\n      current = current.left;\n    }\n    return current;\n  }\n\n  minimum() {\n    return this._minimumChild().value;\n  }\n\n  _maximumChild() {\n    let current = this;\n    while (current.right !== undefined) {\n      current = current.right;\n    }\n    return current;\n  }\n\n  maximum() {\n    return this._maximumChild().value;\n  }\n\n  remove(value) {\n    let identifiedValue = this.identifier(value);\n    let thisValue = this.identifier(this.value);\n    if (thisValue === identifiedValue) {\n      if (this.isLeaf) {\n        if (this.isRoot) {\n          this.value = undefined;\n        } else if (this.isRightChild) {\n          this.parent.right = undefined;\n        } else if (this.isLeftChild) {\n          this.parent.left = undefined;\n        }\n      } else if (this.hasOneChild) {\n        let rmDir = this.right ? LEFT : RIGHT;\n        this.right ? this.rotateLeft() : this.rotateRight();\n        this.children[rmDir] = undefined;\n      } else if (this.hasTwoChildren) {\n        let replacement = this.right._minimumChild();\n        this.value = replacement.value;\n        this.right.remove(replacement.value);\n      }\n    } else {\n      let dir;\n      if (thisValue < identifiedValue) {\n        dir = RIGHT;\n      } else {\n        dir = LEFT;\n      }\n      if (this.children[dir] === undefined) {\n        return undefined;\n      } else {\n        return this.children[dir].remove(value);\n      }\n    }\n  }\n}\n","import * as d3 from \"d3\";\nimport { CANVAS_WIDTH, CANVAS_HEIGHT, CIRCLE_RADIUS } from \"../config\";\nimport { defineArrowMarkers } from \"./defineArrowMarkers\";\n\nexport const initSvg = () => {\n  const svg = d3\n    .select(\"body\")\n    .append(\"svg\")\n    .attr(\"width\", CANVAS_WIDTH + CIRCLE_RADIUS * 2)\n    .attr(\"height\", CANVAS_HEIGHT + CIRCLE_RADIUS * 2);\n\n  defineArrowMarkers(svg);\n\n  const canvas = svg\n    .append(\"g\")\n    .attr(\"transform\", `translate(${CIRCLE_RADIUS}, ${CIRCLE_RADIUS})`);\n\n  return canvas;\n};\n","export const defineArrowMarkers = svg => {\n  const defs = svg.append(\"defs\");\n\n  defs\n    .append(\"marker\")\n    .attr(\"id\", \"blackTriangle\")\n    .attr(\"refX\", 6)\n    .attr(\"refY\", 6)\n    .attr(\"markerWidth\", 30)\n    .attr(\"markerHeight\", 30)\n    .attr(\"markerUnits\", \"userSpaceOnUse\")\n    .attr(\"orient\", \"auto\")\n    .append(\"path\")\n    .attr(\"d\", \"M 0 0 12 6 0 12 3 6\")\n    .attr(\"fill\", \"black\");\n\n  defs\n    .append(\"marker\")\n    .attr(\"id\", \"blueTriangle\")\n    .attr(\"refX\", 6)\n    .attr(\"refY\", 6)\n    .attr(\"markerWidth\", 30)\n    .attr(\"markerHeight\", 30)\n    .attr(\"markerUnits\", \"userSpaceOnUse\")\n    .attr(\"orient\", \"auto\")\n    .append(\"path\")\n    .attr(\"d\", \"M 0 0 12 6 0 12 3 6\")\n    .attr(\"fill\", \"blue\");\n};\n","import * as d3 from \"d3\";\n\nexport const canvasTest = canvas => {\n  const t = d3.transition().duration(500);\n\n  canvas\n    .append(\"line\")\n    .attr(\"x1\", 100)\n    .attr(\"y1\", 100)\n    .attr(\"x2\", 200)\n    .attr(\"y2\", 200)\n    .attr(\"stroke-width\", 1)\n    .attr(\"stroke\", \"blue\")\n    .attr(\"opacity\", 1)\n    .attr(\"marker-end\", \"url(#blueTriangle)\")\n    .transition(t)\n    .attr(\"x2\", 500)\n    .attr(\"y2\", 100)\n    .attr(\"opacity\", 0.3);\n};\n","import { useEffect } from \"react\";\nimport AnimatedTree from \"../animations/AnimatedTree\";\nimport { canvasTest, initSvg } from \"../helpers\";\n\nconst runVisualization = async () => {\n  const canvas = initSvg();\n  canvasTest(canvas);\n\n  const animatedTree = new AnimatedTree(canvas);\n\n  for (let i = 0; i <= 50; i++) {\n    await animatedTree.insert(i);\n  }\n\n  console.log(animatedTree);\n\n  for (let i = 50; i >= 20; i--) {\n    await animatedTree.remove(i);\n  }\n\n  console.log(animatedTree);\n};\n\nfunction Tree() {\n  useEffect(() => {\n    runVisualization();\n  }, []);\n\n  return null;\n}\n\nexport default Tree;\n","import React from \"react\";\nimport \"./App.css\";\n\nimport Tree from \"./components/Tree\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Tree />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}