import React from "react";
import "./App.css";

import { /* BinaryTree, */ RedBlackTree } from "./RedBlackTree";

function App() {
  const tree = new RedBlackTree(0);

  const children = [];
  for (let i = 1; i < 500; i++) {
    let child = tree.insert(i);
    children.push(child);
  }

  for (let i = 499; i > 100; i--) {
    tree.remove(i);
  }

  for (let i = 0; i < 100; i++) {
    console.log(children[i].countBlackToRoot());
  }

  return (
    <div className="App">
      <header className="App-header">
                <h1>Red Black Tree Player</h1>
        <a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        >
          Gihub
        </a>
        <p>
          Решил тут подразобраться в алгоритмах. Начал искать что-нибудь
          интересное , достаточно сложное, чтобы мозг размять, но не слишком,
          чтобы не биться лбом о стену пытаясь "сдвинуть гору Фудзи". Привлекли
          красно-черные деревья. Вроде бы как тема очень изученная , но весь
          найденный материал меня не совсем устроил. Занимаюсь React, поэтому
          искал код на javascript. Нашел замечательный репозиторий
          https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/tree/red-black-tree
          , но там почему - то не оказалось кода удаления елемента. Загорелся
          идеей сделать свою визуализацию, чтобы можно было удобно смотреть что
          к чему. На ум пришло, что будет удобно сделать в виде плеера. Чтобы
          можно было остановить, прокрутить вперед-назад на разной скорости или
          по шагам. Оказалось, что визуализация уже есть
          https://www.cs.usfca.edu/~galles/visualization/RedBlack.html.
          Впринципе круто, но есть что улучшить. Чтобы плей работал вперед и
          назад, что-нибудь типа "проигрывать вперед", "проигрывать назад".
          Чтобы после окончания анимации можно было по шагам двигаться и вперед
          и назад (на визуализации по ссылке надо успеть остановить до
          окончания, иначе пропадет "шаг назад"). Чтобы исходный код был простым
          и можно было его посмотреть. Понравилась статья с медиума
          https://medium.com/@julianknodt/red-black-trees-in-javascript-c20eec1d5d1c,
          классные исходники, но почему то фотками. Теряюсь в догадках, с чем
          это может быть связано? Автор статьи почему-то ссылку на репозиторий
          не дал, но дал ссылку на неплохую статью
          https://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/. В
          общем, решил , что ради интереса стоит сделать свой вариант. Опишу тут
          вкратце, что к чему. Есть два режима работы. Режим "рандом", когда
          числа от одного до 100 случайно добавляются и случайно удаляются. И
          режим перетаскивания, когда из общей кучи числа перетаскиваются на
          дерево или "отрываются" от дерева. Скорость анимации регулируется. При
          желании можно остановить непрерывную анимацию и проиграть все вперед
          назад пошагово.
        </p>
        <p>
          Мысли: возможно сделать регулировку скорости серкл прогресом, а листья
          дерева похожими на реальные листья. Режим непрерывной анимации
          вперед/назад с регулируемой скоростью и рандомным выбором чисел из
          облака чисел, и потом с рандомным удалением чисел из облака.
          Аналогично , но с покадровым перешагиванием и возможностью шагать
          вперед/назад
        </p>
        <p>
          Еще мысли: нарисовать, чтобы ссылки красиво направлялись и удлинялись
          или истаивали и рассыпались
        </p>
        <p>
          Создать linked list (натягать из кучи или рандомно сгенерированный),
          потом запустить анимация превращения линкед листа в красно - черное
          дерево, из которого рандомно будут удаляться узлы, с возможностью
          паузы, регулировкой скорости , изменением направления анимации вперед
          и назад
        </p>
        <p>
          Итого, для начала подобрать список данных так, чтобы он красиво
          преобразовывался в красно черное дерево, перебирал все кейсы алгоритма
          и сделать, чтобы это преобразование проигрывалось вперед и назад,
          можно было менять скорость и направление проигрывания или ставить на
          паузу (например, чтобы проигрывание зависело от величины скорости,
          если позитивная скорость, то проигрывание вперед, если негативная , то
          назад, если нулевая , то пауза). Подобрать список для вставки и
          подобрать порядок, в котором из дерева будут удаляться узлы, перебирая
          все кейсы удаления. Для управления проигрыванием оставить только
          ползунок скорости (который будет менять цвет на направлениях и
          остановке).
          Палитру цветов для линий и элементов можно взять из vs code
        </p>
      </header>
    </div>
  );
}

export default App;
